SEG
MOVE W I H'0000FFFF', SP -- Stack init
JUMP start

a:	DD W 4
b:	DD W 5

-- Unterpogramm mul(a, b)
-- Berechne a*b rekursiv: mul(a,b) = a * mul(a, b-1)

mul:
	PUSHR			-- Sichere Register
	-- Register 0-15 werden AUF den Stack gelegt
	-- Wir muessen also a,b 'unter' diesen Registern laden
	-- Deswegen 64+!SP, denn 16*4 Platz wird von Registern eingenommen
	MOVE W 64+!SP, R0 	-- Lade a vom Stack in RO
	-- Das sind nur lesende Zugriffe, die Elemente werden nicht vom Stack genommen
	MOVE W 68+!SP, R1 	-- Lade b vom Stack in R1
	CMP W R1, I 1		-- Basisfall -> wenn b=1 -> a*1 = a
	JEQ base
	SUB W I 1, R1, R1 	-- b = b - 1

	-- Bereite Aufruf von mul(a,b-1) vor
	MOVE W I -1, -!SP 	-- Platz fuer Rueckgabe
	MOVE W R0, -!SP 		-- Lege a auf Stack
	MOVE W R1, -!SP 		-- Lege b - 1 auf Stack

	CALL mul 		-- Berechne mul(a, b-1)

	-- mul(a,b-1) wurde berechnet, hole Ergebnis
	-- !SP+ ist ein POP vom Stack, das oberste Element wird vom Stack !entfernt!
	MOVE W !SP+, R2 		-- Stack bereinigen
	MOVE W !SP+, R2		-- Stack bereinigen (2x denn 2 Parameter)
	MOVE W !SP+, R2		-- Hole Rueckgabewert
	ADD W R0, R2, 72+!SP 	-- Lege a + mul(a, b-1) in den Stack als Rueckgabe
	-- Beachte: hier 72+!SP, denn 64 Byte von Registern, dann 2*4 Byte von den beiden Parametern
	-- und darunter ist dann unser vorher mit -1 reservierter Platz!
	JUMP return
base:
	MOVE W R0, 72+!SP 	-- Lege rueckgabewert (a*1 = a) an vorher reservierte Stelle
return:
	POPR			-- Stelle Register wieder her
	RET			-- Beende Unterprogramm
start:
	MOVE W I -1, -!SP 	-- Platz fuer Rueckgabe
	MOVE W b, -!SP 		-- b auf Stack
	MOVE W a, -!SP 		-- a auf Stack
	-- Stack wird wie ein Stapel aufgebaut, deshalb liegt nun !a! oben auf dem Stack, als erster Parameter
	CALL mul
	MOVE W !SP+, R0 		-- Stack bereinigen (Hier lag der Parameter a)
	MOVE W !SP+, R0 		-- Stack bereinigen (Hier lag der Parameter b)
	MOVE W !SP+, R0 		-- Ergebnis in R0
	HALT
	END
	
